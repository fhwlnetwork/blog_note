import{_ as l}from"./chunks/ArticleMetadata.Sb1DYAHo.js";import{_ as k,D as p,o as e,c as r,I as o,w as d,k as t,a as c,R as g,b as F,e as C}from"./chunks/framework.FVQzxbLi.js";import"./chunks/md5.RtphNWHi.js";const P=JSON.parse('{"title":"Docker网络","description":"","frontmatter":{"title":"Docker网络","author":"吴建华","date":"2022/10/22 21:25","categories":["docker高级篇"],"tags":["docker","Linux"],"showArticleMetadata":false,"editLink":false,"lastUpdated":false,"showComment":false},"headers":[],"relativePath":"courses/cloud/02-docker高级篇/05-docker_network.md","filePath":"courses/cloud/02-docker高级篇/05-docker_network.md","lastUpdated":1702564575000}'),m={name:"courses/cloud/02-docker高级篇/05-docker_network.md"},y=t("h1",{id:"docker网络",tabindex:"-1"},[c("Docker网络 "),t("a",{class:"header-anchor",href:"#docker网络","aria-label":'Permalink to "Docker网络"'},"​")],-1),u=g(`<h2 id="是什么" tabindex="-1">是什么 <a class="header-anchor" href="#是什么" aria-label="Permalink to &quot;是什么&quot;">​</a></h2><p>docker不启动，默认网络情况下网卡为 ens33/eth0 lo virbro</p><blockquote><p>virbro说明：</p><p>在CentOS7的安装过程中如果有选择相关虚拟化的的服务安装系统后，启动网卡时会发现有一个以网桥连接的私网地址的virbr0网卡(virbr0网卡：它还有一个固定的默认IP地址192.168.122.1)，是做虚拟机网桥的使用的，其作用是为连接其上的虚机网卡提供 NAT访问外网的功能。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071537091.png" alt="image-20220207153527587"></p><h2 id="常用基本命令" tabindex="-1">常用基本命令 <a class="header-anchor" href="#常用基本命令" aria-label="Permalink to &quot;常用基本命令&quot;">​</a></h2><h3 id="查看网络" tabindex="-1">查看网络 <a class="header-anchor" href="#查看网络" aria-label="Permalink to &quot;查看网络&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> netwokr</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ls</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071549526.png" alt="image-20220207154925404"></p><h3 id="查看网络源数据" tabindex="-1">查看网络源数据 <a class="header-anchor" href="#查看网络源数据" aria-label="Permalink to &quot;查看网络源数据&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]# docker network inspect bridge</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071553493.png" alt="image-20220207155321421"></p><h3 id="创建、删除网络" tabindex="-1">创建、删除网络 <a class="header-anchor" href="#创建、删除网络" aria-label="Permalink to &quot;创建、删除网络&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]# docker network create test_network</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]# docker network ls</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]# docker network rm test_network</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071557208.png" alt="image-20220207155709139"></p><h2 id="能干嘛" tabindex="-1">能干嘛 <a class="header-anchor" href="#能干嘛" aria-label="Permalink to &quot;能干嘛&quot;">​</a></h2><p>1、容器间的互联和通信以及端口映射</p><p>2、容器IP变动时候可以通过服务名直接网络通信而不受到影响</p><h2 id="网络模式" tabindex="-1">网络模式 <a class="header-anchor" href="#网络模式" aria-label="Permalink to &quot;网络模式&quot;">​</a></h2><h3 id="网络模式-1" tabindex="-1">网络模式 <a class="header-anchor" href="#网络模式-1" aria-label="Permalink to &quot;网络模式&quot;">​</a></h3><blockquote><p>bridge模式：使用--network bridge指定，默认使用docker0</p><p>host模式：使用--network host指定</p><p>none模式：使用--network none指定</p><p>container模式：使用--network container:NAME或者容器ID指定</p></blockquote><h4 id="bridge" tabindex="-1">bridge <a class="header-anchor" href="#bridge" aria-label="Permalink to &quot;bridge&quot;">​</a></h4><p>ocker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p><p>查看 bridge 网络的详细信息，并通过 grep 获取名称项</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]# docker network inspect bridge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> name</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">            &quot;com.docker.network.bridge.name&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;docker0&quot;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]# ifconfig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> docker</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker0:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> flags=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">4099</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">UP,BROADCAST,MULTICAS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  mtu</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1500</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[root@wjh </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]#</span></span></code></pre></div><p>1、Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p><p>2、docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig,就可以看到docker0和自己create的network(后面讲)eth0，eth1，eth2……代表网卡一，网卡二，网卡三……，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址</p><p>3、网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。 3.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）； 3.2 每个容器实例内部也有一块网卡，每个接口叫eth0； 3.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。 通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071614441.png" alt="image-20220207161419350"></p><h5 id="案例" tabindex="-1">案例 <a class="header-anchor" href="#案例" aria-label="Permalink to &quot;案例&quot;">​</a></h5><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8081</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat81</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8082</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat82</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071649029.png" alt="image-20220207164918893"></p><h4 id="host" tabindex="-1">host <a class="header-anchor" href="#host" aria-label="Permalink to &quot;host&quot;">​</a></h4><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8083</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> host</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat83</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071652000.png" alt="image-20220207165209333"></p><blockquote><p>问题： docke启动时总是遇见标题中的警告 原因： docker启动时指定--network=host或-net=host，如果还指定了-p映射端口，那这个时候就会有此警告， 并且通过-p设置的参数将不会起到任何作用，端口号会以主机端口号为主，重复时则递增。 解决: 解决的办法就是使用docker的其他网络模式，例如--network=bridge，这样就可以解决问题，或者直接无视</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">                          --network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> host</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat84</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071653674.png" alt="image-20220207165328614"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071659401.png" alt="image-20220207165939319"></p><p>在浏览器访问容器内的tomcat83看到访问成功，因为此时容器的IP借用主机的，所以容器共享宿主机网络IP，这样的好处是外部主机与容器可以直接通信。</p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071708931.png" alt="image-20220207170828808"></p><h4 id="node" tabindex="-1">node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;node&quot;">​</a></h4><p>禁用网络功能，只有lo标识(就是127.0.0.1表示本地回环)</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8084</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> none</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat84</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span></code></pre></div><h4 id="container" tabindex="-1">container <a class="header-anchor" href="#container" aria-label="Permalink to &quot;container&quot;">​</a></h4><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><h5 id="案例-1" tabindex="-1">案例 <a class="header-anchor" href="#案例-1" aria-label="Permalink to &quot;案例&quot;">​</a></h5><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -it</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">                                                    --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> alpine1</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  alpine</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /bin/sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -it</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> container:alpine1</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> alpine2</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  alpine</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /bin/sh</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071726120.png" alt="image-20220207172611021"></p><p>当alpine退出后再看alpine2的IP只剩下lo</p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071729060.png" alt="image-20220207172912944"></p><h4 id="自定义网络" tabindex="-1">自定义网络 <a class="header-anchor" href="#自定义网络" aria-label="Permalink to &quot;自定义网络&quot;">​</a></h4><p>自定义桥接网络,自定义网络默认使用的是桥接网络bridge</p><h5 id="案例-2" tabindex="-1">案例 <a class="header-anchor" href="#案例-2" aria-label="Permalink to &quot;案例&quot;">​</a></h5><p>创建网络</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> wjh_network</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ls</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071735264.png" alt="image-20220207173524199"></p><p>新建容器加入上一步新建的自定义网络</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8081</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> wjh_network</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">  --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat81</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8082</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> wjh_network</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">  --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> tomcat82</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> billygoo/tomcat8-jdk8</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/202202071740216.png" alt="image-20220207174015113"></p><blockquote><p>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p></blockquote><h2 id="整体说明" tabindex="-1">整体说明 <a class="header-anchor" href="#整体说明" aria-label="Permalink to &quot;整体说明&quot;">​</a></h2><p>从其架构和运行流程来看，Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker 运行的基本流程为：</p><p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。 2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。 3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。 4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph driver将下载镜像以Graph的形式存储。 5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。 6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。 7 Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。</p>`,63);function b(s,D,v,w,B,_){const h=l,n=p("ClientOnly");return e(),r("div",null,[y,o(n,null,{default:d(()=>{var i,a;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(e(),F(h,{key:0,article:s.$frontmatter},null,8,["article"])):C("",!0)]}),_:1}),u])}const j=k(m,[["render",b]]);export{P as __pageData,j as default};
