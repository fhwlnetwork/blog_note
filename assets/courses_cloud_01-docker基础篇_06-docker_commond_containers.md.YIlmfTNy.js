import{_ as r}from"./chunks/ArticleMetadata.Sb1DYAHo.js";import{_ as p,D as l,o as s,c,I as d,w as h,k as i,a as g,R as m,b as k,e as u}from"./chunks/framework.FVQzxbLi.js";import"./chunks/md5.RtphNWHi.js";const I=JSON.parse('{"title":"容器命令","description":"","frontmatter":{"title":"容器命令","author":"吴建华","date":"2021/01/16 17:58","categories":["docker基础篇"],"tags":["乌班图","docker","linux"]},"headers":[],"relativePath":"courses/cloud/01-docker基础篇/06-docker_commond_containers.md","filePath":"courses/cloud/01-docker基础篇/06-docker_commond_containers.md","lastUpdated":1702605175000}'),b={name:"courses/cloud/01-docker基础篇/06-docker_commond_containers.md"},v=i("h1",{id:"容器命令",tabindex:"-1"},[g("容器命令 "),i("a",{class:"header-anchor",href:"#容器命令","aria-label":'Permalink to "容器命令"'},"​")],-1),f=m(`<h2 id="新建-启动容器" tabindex="-1">新建+启动容器 <a class="header-anchor" href="#新建-启动容器" aria-label="Permalink to &quot;新建+启动容器&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [OPTIONS] IMAGE[COMMAD][ARG...]</span></span></code></pre></div><blockquote><p>options说明：有些是一个减号，有些是两个减号</p><p>--name=&quot;容器新名字&quot; 为容器指定一个名称；</p><p>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p><p>-i：以交互模式运行容器，通常与 -t 同时使用；</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>也即启动交互式容器(前台有伪终端，等待交互)；</p><p>-P: 随机端口映射，大写P</p><p>-p: 指定端口映射，小写p</p></blockquote><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">-p hostPort:containerPort</td><td style="text-align:left;">端口映射 -p 8080:80</td></tr><tr><td style="text-align:left;">-p hostPort:containerPort</td><td style="text-align:left;">配置监听地址 -p 10.0.0.100:8000:80</td></tr><tr><td style="text-align:left;">-p hostPort:containerPort:udp</td><td style="text-align:left;">指定协议 -p 8080:80:tcp</td></tr><tr><td style="text-align:left;">-p 81:80 -p 443:443</td><td style="text-align:left;">指定多个</td></tr></tbody></table><h3 id="a-name-交互式-使用镜像centos-latest以交互模式启动一个容器-在容器内执行-bin-bash命令。-a" tabindex="-1"><code>&lt;a name=&quot;交互式&quot;&gt;</code>使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<code>&lt;/a&gt;</code> <a class="header-anchor" href="#a-name-交互式-使用镜像centos-latest以交互模式启动一个容器-在容器内执行-bin-bash命令。-a" aria-label="Permalink to &quot;\`&lt;a name=&quot;交互式&quot;&gt;\`使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。\`&lt;/a&gt;\`&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker run -it centos /bin/bash</span></span></code></pre></div><blockquote><p>参数说明：</p><p>-i: 交互式操作。 -t: 终端。 centos : centos 镜像。 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 要退出终端，直接输入 exit:</p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204102219542.png" alt="image-20220204102219542"></p></blockquote><h2 id="列出当前所有正在运行的容器" tabindex="-1">列出当前所有正在运行的容器 <a class="header-anchor" href="#列出当前所有正在运行的容器" aria-label="Permalink to &quot;列出当前所有正在运行的容器&quot;">​</a></h2><blockquote><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker ps [OPTIONS]</span></span></code></pre></div><p>OPTIONS说明（常用）：</p><p>-a :列出当前所有正在运行的容器+历史上运行过的 -l :显示最近创建的容器。 -n：显示最近n个创建的容器。 -q :静默模式，只显示容器编号。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204102515251.png" alt="image-20220204102515251"></p><h2 id="退出容器" tabindex="-1">退出容器 <a class="header-anchor" href="#退出容器" aria-label="Permalink to &quot;退出容器&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># exit</span></span></code></pre></div><blockquote><p>run进去容器，exit退出，容器停止</p></blockquote><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  # ctrl+p+q</span></span></code></pre></div><blockquote><p>run进去容器，ctrl+p+q退出，容器不停止</p></blockquote><h2 id="启动已停止运行的容器" tabindex="-1">启动已停止运行的容器 <a class="header-anchor" href="#启动已停止运行的容器" aria-label="Permalink to &quot;启动已停止运行的容器&quot;">​</a></h2><blockquote><pre><code>docker start 容器ID或者容器名
</code></pre></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204103144440.png" alt="image-20220204103144440"></p><h2 id="重启容器" tabindex="-1">重启容器 <a class="header-anchor" href="#重启容器" aria-label="Permalink to &quot;重启容器&quot;">​</a></h2><blockquote><p>docker restart 容器ID或者容器名</p></blockquote><h2 id="停止容器" tabindex="-1">停止容器 <a class="header-anchor" href="#停止容器" aria-label="Permalink to &quot;停止容器&quot;">​</a></h2><blockquote><pre><code>docker stop 容器ID或者容器名
</code></pre></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204103111540-20220204103247664.png" alt=""></p><h2 id="强制停止容器" tabindex="-1">强制停止容器 <a class="header-anchor" href="#强制停止容器" aria-label="Permalink to &quot;强制停止容器&quot;">​</a></h2><blockquote><pre><code>docker kill 容器ID或容器名
</code></pre></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204103342655.png" alt="image-20220204103342655"></p><h2 id="删除已停止的容器" tabindex="-1">删除已停止的容器 <a class="header-anchor" href="#删除已停止的容器" aria-label="Permalink to &quot;删除已停止的容器&quot;">​</a></h2><blockquote><p>docker rm 容器ID</p><p>一次性删除多个容器实例</p><p>docker rm -f $(docker ps -a -q)</p><p>docker ps -a -q | xargs docker rm</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204120030408.png" alt="image-20220204120030408"></p><h2 id="启动守护式容器-后台服务器" tabindex="-1">启动守护式容器(后台服务器) <a class="header-anchor" href="#启动守护式容器-后台服务器" aria-label="Permalink to &quot;启动守护式容器(后台服务器)&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker run -d 镜像名称</span></span></code></pre></div><p>#使用镜像centos:latest以后台模式启动一个容器</p><blockquote><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker run -d centos</span></span></code></pre></div><p>问题：然后docker ps -a 进行查看, 会发现容器已经退出</p><p>很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.</p><p>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,</p><p>我们配置启动服务只需要启动响应的service即可。例如service nginx start</p><p>但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,</p><p>这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.</p></blockquote><h3 id="前台交互式启动" tabindex="-1">前台交互式启动 <a class="header-anchor" href="#前台交互式启动" aria-label="Permalink to &quot;前台交互式启动&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker run -it redis:6.0.8</span></span></code></pre></div><blockquote><p><code>&lt;a href=&quot;#交互式&quot;&gt;</code>操作截图见第一节<code>&lt;/a&gt;</code></p></blockquote><h3 id="后台守护式启动" tabindex="-1">后台守护式启动 <a class="header-anchor" href="#后台守护式启动" aria-label="Permalink to &quot;后台守护式启动&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker run -d redis:6.0.8</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204103901575.png" alt="image-20220204103901575"></p><h3 id="查看容器日志" tabindex="-1">查看容器日志 <a class="header-anchor" href="#查看容器日志" aria-label="Permalink to &quot;查看容器日志&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker logs 容器ID</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204104725953.png" alt="image-20220204104725953"></p><h3 id="查看容器内运行的进程" tabindex="-1">查看容器内运行的进程 <a class="header-anchor" href="#查看容器内运行的进程" aria-label="Permalink to &quot;查看容器内运行的进程&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker top 容器ID</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204104749617.png" alt="image-20220204104749617"></p><h3 id="查看容器内部细节" tabindex="-1">查看容器内部细节 <a class="header-anchor" href="#查看容器内部细节" aria-label="Permalink to &quot;查看容器内部细节&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker inspect 容器ID</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204104821731.png" alt="image-20220204104821731"></p><h3 id="进入正在运行的容器并以命令行交互" tabindex="-1">进入正在运行的容器并以命令行交互 <a class="header-anchor" href="#进入正在运行的容器并以命令行交互" aria-label="Permalink to &quot;进入正在运行的容器并以命令行交互&quot;">​</a></h3><h3 id="docker-exec进入容器" tabindex="-1">docker exec进入容器 <a class="header-anchor" href="#docker-exec进入容器" aria-label="Permalink to &quot;docker exec进入容器&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker exec -it 容器ID bash</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204105819180.png" alt="image-20220204105819180"></p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204105842456.png" alt="image-20220204105842456"></p><h3 id="docker-attach-重新进入容器" tabindex="-1">docker attach 重新进入容器 <a class="header-anchor" href="#docker-attach-重新进入容器" aria-label="Permalink to &quot;docker attach 重新进入容器&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># docker attach</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204110159671.png" alt="image-20220204110159671"></p><blockquote><p><strong>attach与exec比对</strong></p><p>attach 直接进入容器启动命令的终端，不会启动新的进程用exit退出，会导致容器的停止。 exec 是在容器中打开新的终端，并且可以启动新的进程用exit退出，不会导致容器的停止。</p><p><code>&lt;a style=&quot;color:red&quot;&gt;</code>生产中推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。<code>&lt;/a&gt;</code></p></blockquote><h4 id="用之前的redis容器实例进入试试" tabindex="-1">用之前的redis容器实例进入试试 <a class="header-anchor" href="#用之前的redis容器实例进入试试" aria-label="Permalink to &quot;用之前的redis容器实例进入试试&quot;">​</a></h4><p>docker exec -it 容器ID /bin/bash</p><p>docker exec -it 容器ID /bin/bash</p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204110803356.png" alt="image-20220204110803356"></p><h3 id="从容器内拷贝文件到主机上" tabindex="-1">从容器内拷贝文件到主机上 <a class="header-anchor" href="#从容器内拷贝文件到主机上" aria-label="Permalink to &quot;从容器内拷贝文件到主机上&quot;">​</a></h3><blockquote><p>容器→主机 docker cp 容器ID:容器内路径 目的主机路径</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204112203766.png" alt=""></p><h3 id="导入和导出容器" tabindex="-1">导入和导出容器 <a class="header-anchor" href="#导入和导出容器" aria-label="Permalink to &quot;导入和导出容器&quot;">​</a></h3><pre><code>export 导出容器的内容留作为一个tar归档文件[对应import命令]

import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]

案例

docker export 容器ID &gt; 文件名.tar
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204113605251.png" alt="image-20220204113605251"></p><pre><code>cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204113659546.png" alt="image-20220204113659546"></p><h2 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h2><p>attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像</p><p>build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像</p><p>commit Create a new image from a container changes # 提交当前容器为新的镜像</p><p>cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中</p><p>create Create a new container # 创建一个新的容器，同 run，但不启动容器</p><p>diff Inspect changes on a container&#39;s filesystem # 查看 docker 容器变化</p><p>events Get real time events from the server # 从 docker 服务获取容器实时事件</p><p>exec Run a command in an existing container # 在已存在的容器上运行命令</p><p>export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</p><p>history Show the history of an image # 展示一个镜像形成历史</p><p>images List images # 列出系统当前镜像</p><p>import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</p><p>info Display system-wide information # 显示系统相关信息</p><p>inspect Return low-level information on a container # 查看容器详细信息</p><p>kill Kill a running container # kill 指定 docker 容器</p><p>load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]</p><p>login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器</p><p>logout Log out from a Docker registry server # 从当前 Docker registry 退出</p><p>logs Fetch the logs of a container # 输出当前容器日志信息</p><p>port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口</p><p>pause Pause all processes within a container # 暂停容器</p><p>ps List containers # 列出容器列表</p><p>pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像</p><p>push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器</p><p>restart Restart a running container # 重启运行的容器</p><p>rm Remove one or more containers # 移除一个或者多个容器</p><p>rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</p><p>run Run a command in a new container # 创建一个新的容器并运行一个命令</p><p>save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load]</p><p>search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像</p><p>start Start a stopped containers # 启动容器</p><p>stop Stop a running containers # 停止容器</p><p>tag Tag an image into a repository # 给源中镜像打标签</p><p>top Lookup the running processes of a container # 查看容器中运行的进程信息</p><p>unpause Unpause a paused container # 取消暂停容器</p><p>version Show the docker version information # 查看 docker 版本号</p><p>wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值</p>`,107);function q(e,y,x,_,w,P){const o=r,n=l("ClientOnly");return s(),c("div",null,[v,d(n,null,{default:h(()=>{var a,t;return[(((a=e.$frontmatter)==null?void 0:a.aside)??!0)&&(((t=e.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(s(),k(o,{key:0,article:e.$frontmatter},null,8,["article"])):u("",!0)]}),_:1}),f])}const j=p(b,[["render",q]]);export{I as __pageData,j as default};
