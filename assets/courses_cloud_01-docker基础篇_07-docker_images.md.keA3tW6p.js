import{_ as r}from"./chunks/ArticleMetadata.Sb1DYAHo.js";import{_ as l,D as h,o as i,c,I as p,w as k,k as t,a as d,R as m,b as u,e as g}from"./chunks/framework.FVQzxbLi.js";import"./chunks/md5.RtphNWHi.js";const j=JSON.parse('{"title":"docker镜像","description":"","frontmatter":{"title":"docker镜像","author":"吴建华","date":"2022/10/22 21:25","categories":["docker基础篇"],"tags":["docker","Linux"]},"headers":[],"relativePath":"courses/cloud/01-docker基础篇/07-docker_images.md","filePath":"courses/cloud/01-docker基础篇/07-docker_images.md","lastUpdated":1702605175000}'),F={name:"courses/cloud/01-docker基础篇/07-docker_images.md"},b=t("h1",{id:"docker镜像",tabindex:"-1"},[d("docker镜像 "),t("a",{class:"header-anchor",href:"#docker镜像","aria-label":'Permalink to "docker镜像"'},"​")],-1),f=m(`<h2 id="镜像" tabindex="-1">镜像 <a class="header-anchor" href="#镜像" aria-label="Permalink to &quot;镜像&quot;">​</a></h2><pre><code>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。

只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。
</code></pre><h2 id="分层的镜像" tabindex="-1">分层的镜像 <a class="header-anchor" href="#分层的镜像" aria-label="Permalink to &quot;分层的镜像&quot;">​</a></h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204120415744.png" alt="image-20220204120415744"></p><h2 id="unionfs-联合文件系统" tabindex="-1">UnionFS（联合文件系统） <a class="header-anchor" href="#unionfs-联合文件系统" aria-label="Permalink to &quot;UnionFS（联合文件系统）&quot;">​</a></h2><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持 对文件系统的修改作为一次提交来一层层的叠加， 同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承 ，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><blockquote><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p></blockquote><h2 id="docker镜像加载原理" tabindex="-1">Docker镜像加载原理： <a class="header-anchor" href="#docker镜像加载原理" aria-label="Permalink to &quot;Docker镜像加载原理：&quot;">​</a></h2><pre><code>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。

bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统， 在Docker镜像的最底层是引导文件系统bootfs。 这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。

rootfs (root file system) ，在bootfs之上 。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。
</code></pre><p>￼ <img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204121316042.png" alt="image-20220204121316042"></p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="为什么-docker-镜像要采用这种分层结构呢" tabindex="-1">为什么 Docker 镜像要采用这种分层结构呢 <a class="header-anchor" href="#为什么-docker-镜像要采用这种分层结构呢" aria-label="Permalink to &quot;为什么 Docker 镜像要采用这种分层结构呢&quot;">​</a></h2><pre><code>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。
</code></pre><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像； 同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><blockquote><p>Docker镜像层都是只读的，容器层是可写的 当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p></blockquote><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 <img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/20220204121742.png" alt=""></p><h2 id="docker镜像commit操作案例" tabindex="-1">Docker镜像commit操作案例 <a class="header-anchor" href="#docker镜像commit操作案例" aria-label="Permalink to &quot;Docker镜像commit操作案例&quot;">​</a></h2><h3 id="docker-commit提交容器副本使之成为一个新的镜像" tabindex="-1">docker commit提交容器副本使之成为一个新的镜像 <a class="header-anchor" href="#docker-commit提交容器副本使之成为一个新的镜像" aria-label="Permalink to &quot;docker commit提交容器副本使之成为一个新的镜像&quot;">​</a></h3><blockquote><p>命令格式：</p><p>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]</p></blockquote><p>案例演示ubuntu安装vim 从Hub上下载ubuntu镜像到本地并成功运行原始的默认Ubuntu镜像是不带着vim命令的外网连通的情况下，安装vim，安装完成后，commit我们自己的新镜像，启动我们的新镜像并和原来的对比</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#交互式创建容器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@wjh:/home/wjh#</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -it</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ubuntu</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#更新包管理工具</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@ea2af0a25678:/#</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> update</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#安装vim</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@ea2af0a25678:/#</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> apt-get</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -y</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> vim</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204164923452.png" alt="image-20220204164923452"></p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#commit </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@wjh:/home/wjh#</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -m=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;add vim cmd&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -a=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;wjh&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ea2af0a25678</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> wjh/myubuntu:1.0</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/fhwlnetwork/blos_imgs/img/image-20220204165033316.png" alt="image-20220204165033316"></p>`,25);function _(s,y,D,q,v,C){const o=r,n=h("ClientOnly");return i(),c("div",null,[b,p(n,null,{default:k(()=>{var e,a;return[(((e=s.$frontmatter)==null?void 0:e.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(i(),u(o,{key:0,article:s.$frontmatter},null,8,["article"])):g("",!0)]}),_:1}),f])}const S=l(F,[["render",_]]);export{j as __pageData,S as default};
